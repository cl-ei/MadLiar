[
    {
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "Pythonic - 装饰器正解", 
        "id": 20170410, 
        "create_time": "2017年4月10日", 
        "preview": "<img src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n\n　　Python装饰器是Python高级特性中相当重要的一部分，但由于涉及函数式编程、闭包等概念，所以相对难以理解。包括廖雪峰的教程在内，很多教程讲述的都十分晦涩，甚至有很多帖子只是贴出大量没有意义的代码，完完全全是电子垃圾。关于编程，__我们的目的是理解它的原理而写出代码，而不是通过看代码来推敲它的原理__，可偏就有很多人喜欢反其道而行。\n\n", 
        "first_figure": "/static/blog/img/blog/20161231/0.jpeg"
    }, 
    {
        "tags": [
            "学习"
        ], 
        "title": "The 8 bit guy - 一个有趣的频道", 
        "id": 20170407, 
        "create_time": "2017年4月7日", 
        "preview": "<img src=\"/static/blog/img/blog/20170407/0.png\" style=\"width: 100%\">\n\n# 8 bit guy\n　　没错，这个频道讲述的是8位计算机兴起的那个80年代的故事。主播有个观点，就是那个年代不管是对个人计算机还是整个IT科技行业，都是一个黄金时代。虽然在现在看来8位的计算机性能相当差劲、几乎没办法做任何事情，但那是计算机科技真正蓬勃发展时代，不管硬件工业设计还是软件界的百花齐放的繁荣景象，只要经历过的人都印象深刻。举个例子，家喻户晓的《超级玛丽》就诞生于那个年代。刷一刷淘宝，你一定深有同感：那个时代就像被大屏智能手机洗牌之前的手机市场，摩托的刀锋系列、诺基亚的Ngage、7610、5700、N97等等就诞生在那个时代，同样出色的设计层出不穷；而现在给你一台撕掉LOGO的手机，你甚至一眼不能分辨不出来它是什么牌子。\n", 
        "first_figure": "/static/blog/img/blog/20170407/0.png"
    }, 
    {
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "Pythonic", 
        "id": 20170312, 
        "create_time": "2017年3月12日", 
        "preview": "<img src=\"/static/blog/img/blog/20161211/0.jpg\" style=\"width: 100%\">\n\n### 代码规范\n　　谈及Python编程，《PEP 8》总是说不过去的，它是比较官方的代码风格的规范和建议。除此之外，还有《Google编程风格指导》之类的文档等，都是非常不错的文档。代码规范的重要性不言而喻，但这也是人们学习编程时最常忽略的章节。\n\n　　在我读过的入门Python书籍里，中这部分的内容都比较少。但在进阶的书籍中，有的不惜用上两个章节专门讲述，如何写出遵循PEP 8规范的Python代码，并介绍各种工具来审查代码、管理项目结构和文档。当然，事情也没这么复杂，很多时候只要配置一个顺手的IDE就够了。这里我非常推荐PyCharm，它是一款非常优秀的IDE，而且提供免费的社区版。\n", 
        "first_figure": "/static/blog/img/blog/20161211/0.jpg"
    }, 
    {
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.handlers部分)", 
        "id": 20170308, 
        "create_time": "2017年3月8日", 
        "preview": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.handlers\n　　这个模块是WSGI服务器和网关的实现。只要给予一个类CGI的环境，以及输入、输出和错误流，就可以用WSGI应用程序处理绝大部分的网络连接。\n\n* __class__ wsgiref.handlers.__CGIHandler__\n\n\t使用sys.stdin、sys.stdout和sys.stderr流的基于CGI的调用。可以用在你想以一个CGI脚本来运行你写的WSGI应用程序时。它会直接调用```CGIHandler().run(app)```，这里的app就是你想调用的对象。\n\n\t这个class是把wsgi.run_once设置为True、把wsgi.multithread设置为False，而且总是使用sys和os来获取必要的CGI流和环境变量的BaseCGIHandler的派生类。\n\n* __class__ wsgiref.handlers.__BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t与CGIHandler类似，但不使用sys和os，而是显式的指定CGI环境和IO流。*multithread*和*multiprocess*的值是用来给任何通过此实例来运行的应用程序设置*wsgi.multithread*和*wsgi.multiprocess*标志位的。\n\n\t这个类是一个随非HTTP \"origin servers\"软件而使用的SimpleHandler的派生类。如果你想写一个网关接口的实现，比如CGI、FastCGI、SCGI等，使用```Status: ```头来发送一个HTTP的状态码，那您肯定很想用这个实例而不是SimpleHandler的实例。\n\n* __class__ wsgiref.handlers.__SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t和上述BaseCGIHandler类似，但为了HTTP origin servers来设计的。如果你正在写一个HTTP服务器的实现，那使用这个类的实例就比BaseCGIHandler要好得多。\n\n\t这个类基于BaseHandler，但覆写了__init__()、get_stdin()、get_stderr()、add_cgi_vars()、_write()和_flush()方法来支持通过这个构造器来显式设置环境和流。支持的环境和流被存储在stdin、stdout、stderr和environ属性里。\n\n* __class__ wsgiref.handlers.__BaseHandler__\n\n\t这是一个用来运行WSGI应用程序的抽象类，虽然原则上你可以派生出一个类来复用，使得他能接收多个请求，但每个实例都应该只处理一个HTTP请求。\n\n __BaseHandler__只有一个用于外部调用的方法：\n\t- run(*app*)\n\n\t运行指定的WSGI应用程序，如*app*。\n\n 所有其他的方法都只被这个方法调用，用来辅助这个app的运行。这样从根本上可以定制处理过程。\n\n\t- _write(*data*)\n\n\t给字符串*data*做缓冲用来传送到client。如果这个方法发送了data，是OK的，BaseHandler只是区分了写和刷新的操作用于给特定的系统提升效率。\n\n\t- _flush()\n\n\t强制把缓冲区中的数据发送到client。\n\n\t- get_stdin()/get_stderr()\n\n\t返回WSGI请求正在处理之时对应的流。\n\n\t- get_stdvars()\n\n\t插入当前的请求中的CGI变量到environ的属性中。\n\n 另外，有一些方法和属性你肯定想重写它。这里仅列举出一部分，而且在打算基于BaseHandler来定制自己的类之前， 应该翻阅更官方的文档和源码来获得更确切的信息。\n\n\t用来定制WSGI环境的属性和方法如下：\n\n\t- wsgi_multithread\n\n\t用于wsgi.multithread的环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_multiprocess\n\n\t用于wsgi.multiprocess环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_run_once\n\n\t用于wsgi.run_once环境变量.在BaseHandler中默认为False，但CGIHandler中默认为True。\n\n\t- os_environ\n\n\t是每一个请求的WSGI环境中的默认环境变量。默认情况下它是当wsgiref.handlers被import的时候os.environ的拷贝，但派生类也可以在class或者实例层单独创建它们。需要注意的是，这个dict应该被设计成只读的，因为这个默认值是被多个类和实例共享的。\n\n\t- server_software\n\n\t如果设置origin_server属性，它的值将用于设置默认的SERVER_SOFTWARE WSGI环境变量，也会在HTTP响应中设置默认的```Server:```头. 他被非 HTTP origin servers忽略，比如BaseCGIHandler和CGIHandler。\n\n\t- get_scheme()\n\n\t用来返回当前请求的URL方案。默认的实现是使用guess_scheme()方法从wsgiref.util中判定当前的方案是“http”还是“https”，它是基于当前请求的environ变量的。\n\n\t- setup_environ()\n\n\t设置*environ*属性为fully-populated的WSGI环境。默认的实现是使用上述所有的方法加上get_stdin()、get_stderr()、和add_cgi_vars()方法，以及wsgi_file_wrapper属性。如果不存在SERVER_SOFTWARE的key，并且origin_server属性设置为真而且server_software是有值的，它也会插入这个key。\n\n 用来定制处理过程的方法和属性如下：\n\n\t- log_exception(*exc_info*)\n\n\t给*exc_info*元组加上log。*exc_info*是(type, value, traceback) 元组，默认的实现是单纯的写入到wsgi.errors流中，然后flush。派生类可以重写这个方法来改变格式或者重定向输出、发送信息给管理员等等。\n\n\t- traceback_limit\n\n\t定义log_exception()中包含tracebacks输出信息的最大的帧的大小。如果为None，就会包含所有的帧。\n\n\t- error_output(*environ, start_response*)\n\n\t这个方法时一个WSGI应用程序来给用户产生一个error页面。它仅在发送Header之前发生错误时调用。\n\n\t这个方法可以使用sys.exc_info()来进入当前错误信息。并且在被调用时，应当pass这条信息到start_response，在PEP 333中的“Error Handling”章节定义。\n\n\t默认的实现就是使用```error_status```、```error_headers```和```error_body```属性来产生输出的页面。派生类可以重写它来产生更多动态的信息。\n\n\t需要注意的是，从安全的角度来输出诊断信息是不推荐的，要做一些额外的工作来启用诊断输出。这就是为什么默认的实现没有包含任何东西的原因。\n\n\t- error_status\n\n\t用来做HTTP错误回复的状态码。这里应该是PEP 333中定义的一个字符串。默认是一个500的错误码和信息。\n\n\t- error_headers\n\n\t用于错误回复的HTTP headers。它应当是PEP 333中定义的WSGI响应头元组的list，比如[(name, value)]。默认的就是设置“content type”为“text/plain”。\n\n\t- error_body\n\n\t错误回复的body。应该是HTTP响应的body字符串，默认的是纯文本“A server error occurred. Please contact the administrator.”。\n\n PEP 333中定义的“Optional Platform-Specific File Handling”特性相关的方法和属性：\n\n\t- wsgi_file_wrapper\n\n\t为wsgi.file_wrapper的factory，或者为None。默认的值是wsgiref.util中的__FileWrapper__的属性。\n\n\t- sendfile()\n\n\t重写以实现平台特异的文件传输。这个方法只会在应用程序返回的值为wsgi_file_wrapper属性指定的类的实例时被调用。如果成功传送了一个文件它应该返回一个Ture，这样默认的传送代码就不会执行。默认的实现就是返回一个False。\n\n 其他的方法和属性:\n\n\t- origin_server\n\n\t当handler的_write()和_flush()被用来与客户端直接连接，而不是通过类CGI的希望在特殊的```Status:```头中到HTTP状态码网关接口时，这个属性应该被设置为True。\n\n\t在BaseHandler中，这个属性的默认值为True，在BaseCGIHandler和CGIHandler中为假。\n\n\t- http_version\n\n\t如果origin_server为真，这个字符串属性被用来给client设置HTTP版本。默认的是”1.0“。\n\n### 示例用法：\n\n　　一个“Hello World”的WSGI应用程序：\n\n\n```\nfrom wsgiref.simple_server import make_server\n\n# Every WSGI application must have an application object - a callable\n# object that accepts two arguments. For that purpose, we're going to\n# use a function (note that you're not limited to a function, you can\n# use a class for example). The first argument passed to the function\n# is a dictionary containing CGI-style environment variables and the\n# second variable is the callable object (see PEP 333).\ndef hello_world_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n```\n", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg"
    }, 
    {
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (simple_server和validate部分)", 
        "id": 20170307, 
        "create_time": "2017年3月7日", 
        "preview": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.simple_server\n　　这个模块实现了一个基于__BaseHTTPServer__的轻量级WSGI应用程序的服务器。每个server实例只能在设定的主机和端口上调用一个单一的WSGI应用程序，如果要想调用多个WSGI应用程序，必须手动解析PATH_INFO来给每个request做路由，然后决定调用哪个应用程序。\n\n* wsgiref.simple_server.__make_server(*host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler*)__\n\n\t创建一个WSGI server 来监听主机的端口，给*app*接收请求。返回的是*server_class *的实例，并且用指定的*handler_class *来处理request。app必须为PEP 333中定义的WSGI 应用程序对象。\n\n\t示例用法：\n\n\t\tfrom wsgiref.simple_server import make_server, demo_app\n\n\t\thttpd = make_server('', 8000, demo_app)\n\t\tprint \"Serving HTTP on port 8000...\"\n\n\t\t# Respond to requests until process is killed\n\t\thttpd.serve_forever()\n\n\t\t# Alternative: serve one request, then exit\n\t\thttpd.handle_request()\n\n* wsgiref.simple_server.__demo_app(*environ, start_response*)__\n\n\t一个小但完整的WSGI应用程序，返回一个text的页面包含“Hello world!”和一个在*environ *中提供的键值对构成的list，这个主要用来测试WSGI 服务器能否正确的运行一个WSGI应用程序。\n\n* __class__ wsgiref.simple_server.__WSGIServer(*server_address, RequestHandlerClass*)__\n\n\t创建一个WSGIServer的实例，*server_address*必须为(host, port)的元组，并且*RequestHandlerClass*也必须为__BaseHTTPServer.BaseHTTPRequestHandler__的派生类，否则不能正确的处理请求。\n\n\t通常这个方法不需要被调用，因为*make_server()*方法可以处理所有的细节。\n\n\t__WSGIServer__是以__BaseHTTPServer.HTTPServer__为基类的，所以所有BaseHTTPServer.HTTPServer支持的方法都是可用的，比如*server_forever()*、*handle_request()*。__WSGIServer__也提供了专有的方法，比如：\n\n\t* __get_environ()__\n\n\t\t返回WSGI环境变量的dict。默认的实现是，拷贝WSGIServer对象的base_environ dict的内容，然后加上HTTP请求Header导出来的变量再返回。每次请求都会返回PEP 333中定义的包含全部CGI相关的环境变量的全新的dict。\n\n\t* __get_stderr()__\n\n\t\t返回必须用wsgi.errors流的对象。默认的实现其实就是返回__sys.stderr__。\n\n\t* __handle()__\n\n\t\t处理HTTP请求。默认的实现是创建一个句柄实例使用__wsgiref.handlers__类来实际的WSGI API。\n\n### wsgiref.validate\n　　这个模块主要用来检查代码与规范的的一致性。它创建一个在服务器或者网关和应用程序之间检查一致性的function，用以确保两边都相符。\n\n　　需要注意的是，这个模块并不能保证全部的的PEP 333的规范，它没有报错并不意味错误不存在。但一旦它抛出错误，则服务器或者应用程序端必有错误。\n\n　　这个模块基于Ian Bicking的 “Python Paste” 库中的__parse.lint__扩展的。\n\n* wsgiref.validate.__validator(*application*)__\n\n\t装饰一个*application*并且返回一个新的application，返回的application会跟随原application所有的request，并且检查两边的处理是否都符合WSGI和 RFC 2616 中的定义。\n\n\t任何检测到的不服从一致性的错误都将以AssertionError抛出来，但需要注意的是，怎么抛出错误和处理是取决于服务器的。比如__simple_server__和其他基于__handlers__的服务器在错误发生时，会输出一个简单的消息，但如果其他的覆盖了错误处理和做了类似处理的服务器就可能不会抛出。\n\n\t这个装饰器也会用__warnings__模块生成警告，来标识没有明确在PEP 333中禁止但存在问题的行为。除非这些警告被命令行或者__warnings__ API禁止，否则都会被写入到__sys.stderr__。\n\n\t示例用法：\n\n\t\tfrom wsgiref.validate import validator\n\t\tfrom wsgiref.simple_server import make_server\n\n\t\t# Our callable object which is intentionally not compliant to the\n\t\t# standard, so the validator is going to break\n\t\tdef simple_app(environ, start_response):\n\t\t    status = '200 OK'  # HTTP Status\n\t\t    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n\t\t    start_response(status, headers)\n\n\t\t    # This is going to break because we need to return a list, and\n\t\t    # the validator is going to inform us\n\t\t    return \"Hello World\"\n\n\t\t# This is the application wrapped in a validator\n\t\tvalidator_app = validator(simple_app)\n\n\t\thttpd = make_server('', 8000, validator_app)\n\t\tprint \"Listening on port 8000....\"\n\t\thttpd.serve_forever()\n\n\n　", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg"
    }, 
    {
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.headers部分)", 
        "id": 20170306, 
        "create_time": "2017年3月6日", 
        "preview": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.headers\n　　这个模块提供一个Headers的类，用于方便的使用一个mapping-like的接口来操作WSGI头的响应。\n\n* __class__ wsgiref.headers.__Headers(*headers*)__\n\n\t创建一个mapping-like的对象来装饰headers，这个对象必须是由PEP 333中定义的header的name/value元组构成的list。任何更改将直接更新新的Headers对象。\n\n\tHeaders对象支持典型的map操作有```__getitem()__```、```__get()__```、```__setitem()__```、```__setdefault()__```、```__delitem()__```、```__contains()__```、```__haskey()__```等。\n\n\t不管哪种操作，key都是header的name，value是name接下来的第一个值。设置一个header将会删除任何已存在的值，然后追加一个新的值到装饰header的list的末尾。\n\n\t与dict不同的是，即使你试图get或删除一个不存在的key，Headers对象也不会抛出异常，取不存在的key会返回一个None，删除不存在的key则是什么也不做。\n\n\tHeaders对象也同样支持```keys()```、```values()```和```items()```方法。如果有一键多值的Header，可以返回多个list并且keys和items可以包含同一个key多次。对一个Headers对象使用```len()```方法跟len它的items有相同的效果，返回的是装饰Headers的list的长度。```items()```方法指挥返回这个装饰Header的list的副本。\n\n\t对Headers对象使用```str()```方法将会得到一个格式化的字符串，来适配HTTP headers响应的传送。每个header都和它的值置于一行，以冒号和一个空格相隔。每行都终止于“\\r\\n”，并且这个字符串终止于一个空行。\n\n\t除上述之外，Headers对象还支持两种方法来查找和追加一键多值的header、给header添加MIME参数。\n\n\n* __get_all(*name*)__\n\n\t返回一个包含所有这个header中的name/value的list。\n\n\t返回的list的顺序是根据他们在原header中出现的先后、添加到实例的先后来决定的，而且可能会重复。任何的字段删除并重新插入，都将追加到header list的末尾。如果没有给定的name没有存在的字段，就返回一个空的list。\n\n\n* __add_header(*name, value, **params*)__\n\n\t添加一个header，并且可能是一键多值的header，可以通过params中特定的key给此方法传入MIME参数。\n\n\tname是要添加的字段，keyword参数可以给这个字段添加MIME参数。每个参数必须为字符串或者None。“_”将会被转化成“-”，因为“-”在Python中是不合法的标识符，但很多MIME参数都包含它。如果参数的值是一个字符串，就会被追加到header的值中，比如```name=\"value\"```。如果是None，就只有name会被添加，这种情况用在无值的MIME参数中。\n\n\t生产实例：\n\n\t\th.add_header('content-disposition', 'attachment', filename='bud.gif')\n\n\t将会回复：\n\n\t\tContent-Disposition: attachment; filename=\"bud.gif\"\n\n", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg"
    }, 
    {
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.util部分)", 
        "id": 20170305, 
        "create_time": "2017年3月5日", 
        "preview": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n### WSGI Utilities and Reference Implementation\n　　WSGI是一个介于web服务器与Python应用程序之间的标准接口，采用标准接口可以使应用程序方便的在各个web服务器间复用和移植。\n\n　　只有web服务器工程师和软件框架的作者才需要了解和关心WSGI设计的每个细节，对于应用层来讲，只需要遵循WSGI协议来安装和使用现有的框架去编写网络程序就够了。wsgiref提供WSGI环境变量以及HTTP header的回复等的各种操作方法，以及性能评测工具。\n\n## wsgiref.util – WSGI environment utilities\n　　此模块包含操作WSGI环境变量的众多方法。WSGI环境变量是一个包含HTTP请求参数的dict，处理函数要使用一个*environ* 的参数来接收它。\n\n* __wsgiref.util.guess_scheme(*environ*)__\n\n\t返回```wsgi.url_scheme```为“http”还是“https”，它是通过检查*environ* dict中的“HTTP”环境变量来实现的。返回值为string类型。\n\n\t此方法在创建一个CGI或CGI类（比如FastCGI）协议的装饰器时非常有用。比如服务器在收到基于SSL的请求时，在协议中会包含一个“HTTPS”的变量，其值为“1”、“yes”或“on”等，那么使用此方法将会返回一个“https”，否则就是“http”。\n\n\n* __wsgiref.util.request_uri(*environ, include_query=1*)__\n\n\t返回完整的请求的URI，通过*include_query* 参数来决定是否包含query string。判定算法使用的是PEP 333中的”URL Reconstruction“。\n\n\n* __wsgiref.util.application_uri(*environ*)__\n\n\t与request_uri方法类似，但这里忽略了PATH_INFO和QUERY_STRING变量。结果就是请求的应用程序对象地址的base URI。\n\n\n* __wsgiref.util.shift_path_info(*environ*)__\n\n\t从PATH_INFO中移出一个单词到SCRIPT_NAME，并且将之返回。*environ* 将会以空格填补，如果需要的话必须先保存原始的PATH_INFO和SCRIPT_NAME变量。\n\n\t如果PATH_INFO再没有可以移出的部分，执行此方法就会返回一个None。\n\n\t典型情况，一个需求要处理请求URI路径的每个部分，比如遍历一系列的dict的键来修改传入的环境使其适合调用另一个位于目标URI的WSGI程序。比如，有一个WSGI程序位于/foo，而请求的URI路径是/foo/bar/baz，那么位于/foo的应用程序调用 ```shift_path_info()```，将会返回\"bar\"。然后环境将更新来适配位于/foo/bar的WSGI应用程序。这样一来，SCRIPT_NAME将会从/foo变成/foo/bar，PATH_INFO将从/bar/baz变成/baz。\n\n\t当PATH_INFO只剩“/”，就返回一个空的string并且给SCRIPT_NAME追加一个反斜杠，即便是空的路径被忽略或者SCRIPT_NAME没有正常的终止于反斜杠。这是故意设置的，来确保在对象遍历时应用程序能够区分以“/x/”和“/x”结尾的URI。\n\n\n* __wsgiref.util.setup_testing_defaults(*environ*)__\n\n 通过默认值来更新*environ*变量，用于测试用途。\n\n 这个路由添加多个用于请求WSGI的参数，包括HTTP_HOST、SERVER_NAME、SERVER_PORT、REQUEST_METHOD、SCRIPT_NAME、PATH_INFO和所有在PEP 333中定义的以“wsgi.”开头的变量。只支持默认的值，并且不会替换他们当中任何已经存在的设定值。\n\n 此方法主要用来方便的模拟一个环境用于单元测试。由于数据是模拟的，所以不应用于生产服务器和应用程序中。\n\n 一个示例：\n        from wsgiref.util import setup_testing_defaults\n        from wsgiref.simple_server import make_server\n\n        # A relatively simple WSGI application. It's going to print out the\n        # environment dictionary after being updated by setup_testing_defaults\n\n        def simple_app(environ, start_response):\n            setup_testing_defaults(environ)\n\n            status = '200 OK'\n            headers = [('Content-type', 'text/plain')]\n\n            start_response(status, headers)\n\n            ret = [\"%s: %s\\n\" % (key, value) for key, value in environ.iteritems()]\n            return ret\n        httpd = make_server('', 8000, simple_app)\n        print \"Serving on port 8000...\"\n        httpd.serve_forever()\n\n\t除了上述功能，wsgiref.util还提供了一些杂项工具：\n\n* __wsgiref.util.is_hop_by_hop(*header_name*)__\n\n\t如果“‘header_name”是RFC 2616中定义的HTTP/1.1 “Hop-by-Hop” header，则返回True。\n\n\n* ___class___ wsgiref.util.__FileWrapper(*filelike, blksize=8192*)__\n\n\t一个装饰器，用来把file-like对象转换成一个迭代器，返回的对象支持```__getitem__()```和```__iter__()```两种循环风格。当对象迭代时，可选的*blksize*参数将被传入file-like对象的```read()```方法中用来获取产生的字符串。```当read()```方法返回一个空字符串时，迭代结束，且此对象不可恢复。\n\n\t如果file-like对象有一个```close()```方法，那么转换后的对象依然有一个```close()```方法，并且在调用这个对象的```close()```方法时触发file-like对象的```close()```方法。\n\n\t示例：\n\n\t\tfrom StringIO import StringIO\n\t\tfrom wsgiref.util import FileWrapper\n\n\t\t# We're using a StringIO-buffer for as the file-like object\n\n\t\tfilelike = StringIO(\"This is an example file-like object\"*10)\n\t\twrapper = FileWrapper(filelike, blksize=5)\n\n\t\tfor chunk in wrapper:\n\t\t    print chunk\n\n", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg"
    }, 
    {
        "tags": [
            "编程", 
            "学习"
        ], 
        "title": "敬畏之心", 
        "id": 20170202, 
        "create_time": "2017年2月2日", 
        "preview": "<img src=\"/static/blog/img/blog/20170202/0.jpg\" style=\"width: 100%\">\n\n　　几天前老大突然来追问我们工作im群里有个昵称为XX的人是谁，有点怒不可遏。得知此人是合作公司的一位员工之后，老大立即打电话给对方领导要求对其进行批评。我还不明白发生了什么事，但后来才知道事情的起因是这位员工在群里讲的一句话：“谁能告诉我这色块是什么鬼，你们的研发都是刚毕业的吗？” \n\n　　他所说的色块，其实是我们的产品中为了标识某些设备的运行状态而填充的背景色。比方说在一个Excel表里面，运行正常的设备背景色是绿色，离线设备为灰色，故障则为红色等。这个色块其实在内测版本中已经存在了，比较丑陋，但为了赶上线时间就没有对色块进行美化，这个问题也一直遗留至今。\n\n　　这位同事的讲话方式是存在很大问题的。满腹牢骚抱怨、发脾气，除了给这个人打上“低素质”的标签、把事情搞的更糟糕以外，对事情的解决没有任何帮助。这里并不多提讲话的艺术，对于这起突发事件，我则是完全虚心接受对方的批评。因为在我接手的这个项目当中，这种错误并不鲜见：\n\n　　这是我接手的项目中两个页面的部分截图。\n<img src=\"/static/blog/img/blog/20170202/1.png\" style=\"width: 100%\">\n你可能注意到左侧的两句话，下面一句使用了英文的逗号，而上面这句话则是中文逗号。当然这个情有可原，因为这两句话有一句是前端写死的，而另一句是后端渲染的，可能是程序员间交流不密切，才导致了标点的使用不一致的问题。但第二种情况实在令人费解，这四个地方不仅不能统一使用英文或者中文的冒号，连冒号后是否跟一个空格都不能统一！显然这四句都是同一个程序员写的，这就难辞其咎了。且不论这些提示语中语气是否欠妥，连标点符号都不能正确使用，这难道不是要命的问题吗？\n\n　　而后台代码存在的问题更甚。下面是部分生产代码的截图，\n<img src=\"/static/blog/img/blog/20170202/2.png\" style=\"width: 100%\">\n你可以看到这里每个函数的行数，都达到了惊人的1000行以上！我实在不想提及这段代码究竟是谁的作品，我更愿意相信这不是一个人写的，而是多人反复修改、日积月累并且欠缺代码审校和管理，造成的历史问题。其实更严重的不是代码的行数过长，而是没有注释。在上面的代码中艰难的找到了一句注释，\n<img src=\"/static/blog/img/blog/20170202/3.png\" style=\"width: 100%\">\n但却是完完全全的蹩脚的Chinglish，这种注释有什么意义呢？在写注释的问题上，我一直认为给代码写注释并不浪费时间，而且写汉语注释并不丢人。可是很多人就是不愿意加注释，却总在文件开头乐此不疲的写上```__author__ = 'xx'```或者```'''(c)copyright……'''```等……这种行为让我想起自己上一年级的时第一次考完试，我得意的把考了40多分的试卷给老爸看，并以为这是一个很高的分数期待着老爸的夸奖。老爸愤怒的给了我几个字，“恬不知耻！”，这几个字真值得用一生去铭记。\n\n　　这些早已不是技术问题，而是态度问题。为自己“行方便”来制造这些烂代码的人，其实就是在给自己制造骂名。有的人对编程早已失去了敬畏之心，从最初的痴迷与热爱到无关痛痒，最后沦落成人肉编程机。他不再认为编程是门高深的学问和艺术，草草了之，敷衍之，只要代码不出bug就是好的代码。就如我之前，有人问我现在的状态，我说做的事情没有挑战，用时间堆起来就OK。而这样就大错特错了。连基本的代码规范都没有遵循、连标点符号都不能正确使用、连垃圾代码都不知道怎么重构，就敢说所做的事情没有挑战？这跟某人只会点100以内的四则运算并且会买菜做饭生活，然后就说“学数学没什么卵用”、“当会计就是按个计算器对个账本”一样，是无知的表现。\n\n　　有句话叫“永远年轻、永远热泪盈眶”，很多人都知道，但有几个人真正能体会到它的意思呢？我想，那就是要永远保持一颗火热的心、善待热爱的事物，永远对它保持敬畏。学编程第一天，老师就告诉过我们大括号要对齐、注意缩进，养成良好的代码习惯，这应该是每个人都接受过的洗礼。看到有人写非常散漫的代码时，我建议写的整齐一点，却被告知“按Ctrl + i就不就可以了吗？要追求效率，不要纠结细枝末节。”他们说出这些话时，我真的非常震惊，也深切体会到Python的作者为了防止人们写烂代码而强制使用缩进来确定代码块的这一做法背后的无奈。\n\n　　可悲的是，由于强制使用缩进取代大括号，某些IDE格式化代码的功能在Python上会比较有限，甚至没有任何效果，所以很多人又抱怨、吐槽Python使用缩进的做法，这也成为了Python最大的“黑点”。确实，Python没有大括号，在分支比较复杂或者代码块比较长的时候，可读性会急剧下降。但如果认真遵循Python的代码规范的建议，这些问题绝对不会存在。事实上Python确实有一个非常好的文档，就是《PEP 8》。我认为这是每位Python开发者都必读的文档，不仅仅讲述了基本的代码规范，比如应该为```spam(ham[1], {eggs: 2})```而不是```spam( ham[ 1 ],{ eggs : 2 } )```，还有更多json格式、函数等的规范，熟读它会让代码更加优美、可维护性增强。\n\n　　我打算再学习一遍《PEP 8》，还有自己总结的无关代码规范但能显著提高代码美观程度和可读性的一些写作技巧的笔记，并应用到以后的学习和生产当中。这对编程能力也许没有显著的帮助，但至少会在正确的道路上往前迈上一步。\n", 
        "first_figure": "/static/blog/img/blog/20170202/0.jpg"
    }, 
    {
        "tags": [
            "诗和远方"
        ], 
        "title": "诗和远方", 
        "id": 20170127, 
        "create_time": "2017年1月27日", 
        "preview": "<img   src=\"/static/blog/img/blog/20170127/0.jpg\" style=\"width: 100%\">\n　　\n\n我躺在路的中央\n\n举起脚\n\n踩在天上\n\n我想我是醉了\n\n却清楚的看到，\n\n思念的来路，和梦的去处。\n\n<span style=\"float: right;margin-right:20%;\">——慕容引刀</span>\n\n\n　　\n", 
        "first_figure": "/static/blog/img/blog/20170127/0.jpg"
    }, 
    {
        "tags": [
            "生活"
        ],
        "title": "若要离别 必先珍重", 
        "id": 20161231, 
        "create_time": "2016年12月31日", 
        "preview": "<img   src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n　　有人说，人每5年就会历经一次人生转折。即将逝去的2016就是我的一个重大转折。从学生走向职场，这一年发生了太多事，这一年有太多遗憾，这一年是沉重的一年。\n\n## 迷茫的三月\n　　年初因为工作领域不感兴趣而辞掉了offer。这一辞，就是上半年迷茫日子的开始。迷茫，是因为自己根本不知道去哪工作，或者有别的选择。\n\n　　延期毕业是这一年的重磅炸弹。因为当时我还挂着科。毕业论文从阳春三月写到燥热的六月，别人的日子过得很慢，可我却有一大堆麻烦。毕业设计很有难度，是导师一个外包项目的一部分。除此之外为了应付面试，我常常像无头苍蝇一样抱着几本书胡乱翻看、尝试实现书里看起来高大上的东西。我不知道自己在做什么，每一天都这样漫无目的的忙碌，把自己搞得很疲惫。毕业季就在不知所措的忙碌中落幕了。\n\n　　延期毕业是我一直不太愿意提及的事情，但现在已经无所谓了。我始终难以忘怀那个六月。各种聚会接踵而至，饭桌上大家侃侃而谈、各自祝愿前程美好，各种光鲜的客套话，折射的是我失落的情绪。社团里的朋友，聚在一起闲聊。他们讨论着，XX考上了名校研究生，XX签到了年薪几十万的工作，XX才是真大神，而你看CL，看着小牛逼却连毕业证也没拿到……我没有在他们对话的圈子里，是其中一个朋友在后来把这些都告诉了我。\n\n　　不久前的聚会上，我跟一个长辈谈起毕业的事情。七月份潦倒的我来到西安找工作，特别感谢我的老大，在没有毕业证的情况下依然给我工作机会，做我热爱的Python研发。他说，有句话“文凭其实就是一张纸”，这是句鸡汤，但对于你来讲，真的就是这样。每个人追求的事物都各不相同，从在没有在同一条跑道上，何谈谁不如谁呢？有的人就是觉得自己很聪明，但不过就是井底之蛙罢了，这个世界远远不是他所了解的样子。\n\n　　这句话真的是对我最大的勉励。但坦白说，我自己又何尝不是一只井底之蛙呢？我了解自己，自负、处事不决、不能禁受诱惑、太懒……常常是一副举世皆昏我独醒的态度，以为做着比周围的人都正确的事，却浑然不知自己才是最无知的人。过去的都是过去了，不管怎样，我只想对2016的自己说，未来的你不要再做井底之蛙，至少不能甘于做井底之蛙。\n\n## 小黑屋里的回忆\n　　七月份离开了家，我觉得不能再拖累父母。生养二十几年、从镇子上送到大学，作为慈爱的父母，能为儿子做的事情都已经做尽了，我很明白二老几乎再没有什么能帮上自己。未来人生的灯塔，得靠自己寻找。\n\n　　那时候我在离学校很远的地方，租了一间房。那几乎是全西安最便宜的房子了，整个房间只有一张小床，外加一个放鞋的过道，没有窗户，没有阳光，只有一个碗口大的换气窗。更悲惨的是，周围只有一个小的便利店，要吃上一顿正经的饭，就得去3里外的村子。那间房间非常压抑，我躺在床上补功课，在招聘网上刷简历，在那里呆了足足三个月。\n\n　　那个房间看不到日出，看不到日落，听不到雨声风声，不管外面如何，它永远都黑暗、闷热、潮湿。那里什么时候都异常的安静，安静到你能听到自己的心跳，安静到有一种反常的恐怖。在那里住久了，生物钟变得紊乱，常常凌晨四点多就突然醒来再也睡不着，白天呆久了就头晕目眩。我不知道怎么熬过那三个月的，但我想，这辈子应该都不会再住上那样破烂的小屋吧。\n\n　　后来离开了那个地方，搬到了公司附近，房间比以前大了6、7倍，还有一个独立阳台。这里高楼林立，车流嘈杂，每天凌晨一点，对面大楼耀眼的霓虹灯光都能射进我的屋子。搬来第一晚我是失眠的，但我宁愿失眠，因为三个月来我没有过这么开心，兴致勃勃的不睡觉就为了看着对面大楼窗户里的灯光如何一盏盏熄灭，像一个懵懂的孩童在夜空下数星星。\n\n　　我搬到这里来也已经三个多月了。往事不堪回首，但夜深人静时我也有些怀念那个小黑屋。我不知道现在谁在那里住着，谁在那里为了生计奔波，谁在那里失眠于凌晨四点钟。但人应该要住一住这样的屋子，不然怎么能懂得珍惜当下的生活。\n<img   src=\"/static/blog/img/blog/20161231/1.jpg\" style=\"width: 100%\">\n\n## 写给未来\n　　我两次作出考研的决定。但很可惜，都遭到了家人的反对，没有坚持多久就放弃了。他们说考研是风险投资，踏踏实实工作、让生活稳定是最好的出路。我也知道，既然都已离开大学校园，还啃着老，花着爸妈的钱、想着一场泡影，这不是不合适，是不懂事。唯一支持我的是姐姐，她说我没钱了就问她要，资金不是问题，爸妈他们生在旧社会、封建思想根深蒂固，他们不知道我们想要的，不要听他们的话，坚持自己的决定不要留遗憾。姐姐总是很疼我，我真的很感激她。\n\n　　我决定考研，因为我不想让本科的一张成绩单给人一辈子都打上差等生的标签。\n\n　　我拾掇起那一沓落满灰尘的书的时候，我就想着我要给某些人证明一些事情，或者，只证明给自己。我不止一次问自己，这是一条正确的路么？现在的生活，朝九晚五，做的是自己喜欢的事，虽然依然拮据，但至少经济独立。爸妈丝毫不再提及7月份家里爆发的矛盾，每次若无其事的问我女朋的事情，因为他们觉得我的生活已经在轨道上了，下一步就是成家然后生个小娃娃。这就是他们眼中正确的生活。\n\n　　但，这是我想要的生活吗？现在就像温水煮青蛙。工作后学到了很多工程技术，我写出的代码现在也服务于千百万人。但坦诚讲，这样的工作没有多少是真正有技术含量的。安逸的日子久了，人就会有惰性，我怕自己在高科技领域里搬一辈子砖，害怕温床变成大火坑，跳也跳不出来。\n\n　　朋友找我一起吃饭，聊到了大二在社团里纳新时发生的一件事。有位大四的学长投了报名表，但原则上社团只招新人。学长问我，“大四的可以吗？”我跟他说，“只要你有梦想，什么时候都不晚。” 朋友说，大学四年就服我说的这句话，说完那位学长都把打火机和烟盒都忘在了纳新的桌子上。他说这句话很赞。我也突然这么觉得。那刻对于未来如何打算，我已经有了答案。\n\n　　2016结束了，这是难忘的一年，我想对远去的那段艰难的日子说，若要离别，必先珍重。未来还有的新的征程，但这已经没什么好怕的了。\n\n\n\n\n\n\n\n\n　　\n", 
        "first_figure": "/static/blog/img/blog/20161231/0.jpeg"
    }
]